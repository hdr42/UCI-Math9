\documentclass[letterpaper,11pt]{amsart}

\usepackage{amscd,amssymb,amsfonts,amsmath,amsthm,color}
\usepackage{enumerate}
\usepackage{listings}
\usepackage{courier}
\usepackage{graphicx}
\usepackage{scrextend}

\usepackage{calc}
\newsavebox\CBox
\newcommand\hcancel[2][0.5pt]{%
  \ifmmode\sbox\CBox{$#2$}\else\sbox\CBox{#2}\fi%
  \makebox[0pt][l]{\usebox\CBox}%  
  \rule[0.5\ht\CBox-#1/2]{\wd\CBox}{#1}}


\lstset{frame=lrbt,xleftmargin=\fboxsep,xrightmargin=-\fboxsep,colframe=gray}


\lstset{basicstyle=\ttfamily\footnotesize,breaklines=true}


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% margins and style
\pagestyle{plain}
\setlength{\evensidemargin}{0.25in}
\setlength{\oddsidemargin}{0.25in}
\setlength{\textwidth}{6.0in}
\setlength{\topmargin}{0.0in}
\setlength{\textheight}{8.5in}
\setlength{\headheight}{0in}
\setlength{\parskip}{1.5mm}

\linespread{1.2}
\usepackage{color}
\definecolor{gray}{rgb}{0.3,0.3,0.3}



%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% theorems and all 
\theoremstyle{plain}
\newtheorem{theorem}{Theorem}[section]
\newtheorem{lemma}[theorem]{Lemma}
\newtheorem{proposition}[theorem]{Proposition}
\newtheorem{corollary}[theorem]{Corollary}

\theoremstyle{definition}
\newtheorem{definition}[theorem]{Definition}
\newtheorem{remark}[theorem]{Remark}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% renewed commands: t, to, d , c, H

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% Shortcuts for tex commands

\newcommand{\nc}{\newcommand}
\newcommand{\rc}{\renewcommand}
\nc{\mc}{\mathcal}
\rc{\t}{\text}
\nc{\loccit}{\emph{loc. cit. }}
\nc\pf{\noindent Proof: }
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% Operators, functions etc
\nc{\Hom}{\t{Hom}}
\nc{\tot}{\t{tot}}
\nc{\dual}{^{\vee}}
\nc{\op}[1]{\operatorname{#1}}
\nc{\coh}{\t{coh}}
\nc{\iso}{\cong}
\rc{\d}{\operatorname{d}}
\nc{\Id}{\operatorname{Id}}
\nc{\dgmod}{\operatorname{dg-mod}}
\newcommand{\hdot}{^{\raisebox{0pt}{\text{\circle*{2}}}}}
\nc{\compose}{\circ}
\nc{\sheafsym}{\mathcal{S}\t{ym}}
\nc{\rend}{\operatorname{REnd}}
\nc{\rhom}{\operatorname{RHom}}
\nc{\sheafrend}{\mathcal{R}\mc{E}\t{\emph{nd}}}
\nc{\sheafrhom}{\mathcal{R}\mc{H}\t{\emph{om}}}
\nc{\sheafhom}{\mathcal{H}\t{om}}
\nc{\exterior}{{\textstyle\bigwedge\nolimits}}
\nc{\ex}{\exterior}
\nc{\cok}{\operatorname{Coker}}
\rc{\ker}{\operatorname{Ker}}
\nc{\im}{\operatorname{Im}}

%tensor product
\nc{\Lotimes}{{\overset{L}{\otimes}}}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% Arrows and signs
\rc{\to}{\rightarrow}
\nc{\ot}{\leftarrow}
\nc\xto[1]{\xrightarrow{#1}}
\nc{\too}{\longrightarrow}
\nc{\oot}{\longleftarrow}
\nc{\into}{\hookrightarrow}
\nc{\mapsinto}{\hookrightarrow}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% Categories
\nc{\D}{\operatorname{D}}
\nc{\Dsg}{\D_{{sg}}}
\nc{\Db}{\D^{{b}}}
\nc{\Dbgr}{\Db_{{gr}}}
\nc{\Dgr}{\D_{{gr}}}
\nc{\Dsggr}{\Dsg^{{gr}}}
\nc{\Cgr}{\operatorname{C}_{{gr}}}
\nc{\cCgr}{\cC_{gr}}
\nc{\cDgr}{\cD_{gr}}
\nc{\cDsggr}{\cD_{gr}^{sg}}
\nc{\cDbgr}{\cD_{gr}^{b}}
\nc{\cDsg}{\cD_{sg}}
\nc{\cDb}{\cD^{b}}
\rc{\H}{\operatorname{H}}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% Nice letters
% cals
\nc{\cA}{\mc{A}}\nc{\cB}{\mc{B}}\nc{\cC}{\mc{C}}\nc{\cD}{\mc{D}}\nc{\cE}{\mc{E}}\nc{\cF}{\mc{F}}\nc{\cG}{\mc{G}}\nc{\cH}{\mc{H}}\nc{\cI}{\mc{I}}\nc{\cJ}{\mc{J}}\nc{\cK}{\mc{K}}\nc{\cL}{\mc{L}}\nc{\cM}{\mc{M}}\nc{\cN}{\mc{N}}\nc{\cO}{\mc{O}}\nc{\cP}{\mc{P}}\nc{\cQ}{\mc{Q}}\nc{\cR}{\mc{R}}\nc{\cS}{\mc{S}}\nc{\cT}{\mc{T}}\nc{\cU}{\mc{U}}\nc{\cV}{\mc{V}}\nc{\cW}{\mc{W}}\nc{\cX}{\mc{X}}\nc{\cY}{\mc{Y}}\nc{\cZ}{\mc{Z}}
% bbs
\nc{\PP}{\mathbb{P}}
\nc{\CC}{\mathbb{C}}
\nc{\ZZ}{\mathbb{Z}}
\nc{\HH}{\mathbb{H}}
\nc{\NN}{\mathbb{N}}
\nc{\QQ}{\mathbb{Q}}
\nc{\RR}{\mathbb{R}}


\nc{\code}[1]{{\texttt{#1}}}
\nc{\mcode}[1]{{\text{\texttt{#1}}}}



%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% other useful commands
\let\oldmarginpar\marginpar
\renewcommand\marginpar[1]{\-\oldmarginpar[\raggedleft\footnotesize #1]%
{\raggedright\footnotesize #1}}
\nc\note[1]{\marginpar{#1}}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\title{Homework 6}
\date{}
\begin{document}
\maketitle
\begin{center}
  \emph{Due Thursday, March 2, at 11pm}
  \vspace{0.3in}
  \end{center}


\noindent Please enter your answers into a Jupyter notebook and submit by the deadline via canvas. 

\subsection*{Fake Goldbach} More accurately: Goldbach's wrong conjecture. It was proposed by Goldbach that every odd number can be written as the sum of a prime and twice a square. For example:
\begin{eqnarray*}
7 = 7 + 0^2\\
9 = 7 + 2\times 1^2\\
11 = 11 + 0^2\\
15 = 7 + 2\times2^2 \\
21 = 3 + 2\times3^2\\
25 = 7 + 2\times3^2\\
27 = 19 + 2\times2^2\\
33 = 31 + 2\times1^2
\end{eqnarray*}
Prove Golbach wrong by finding the first odd number not to be a prime plus twice a square.

%\subsection*{Monte-Carlo estimation of $\pi$} If we pick a random point on a square
\subsection*{Random walk} A drunk bear called Randi is standing on the origin in $\RR$. At each time step, he goes 1 unit to the left with probability $p = 0.5$ and 1 unit to the right with probability $1-p = 0.5$. Say each random walk is of length $M = 30$ (at which point Randi collapses to the ground). An example simulation of Randi's walk would be \code{[1,0,1,2,1,0,-1,-2,\dots,-3]}.

\begin{itemize}
  \item Make a numpy array of shape (1000, 30) that stores the result of 1000 simulated random walks.
  \item Compute the mean and standard deviation of the ending point of Randi's walk using \code{np.mean} and \code{np.std}.
  \item Make a histogram of where we will find Randi at the end of his walk. 
  \item Let $r_M$ be the ratio of walks where, \emph{at any point during the walk}, Randi returned to the origin. For $M = 1,2,3,4,5,6,7,8,9,\dots,100$, compute $r_M$ and make a graph of $r_M$ as a function of $M$. (idea: you don't need to make a new numpy array every time, make one numpy array of shape (1000,100) and take subarrays to do your computation)
\end{itemize}



\subsection*{Polynomials class v2.0} In the previous homework, we designed a class for Polynomials (please check last week's solutions if you are not sure about this). Our class supported initialization by list (i.e. \code{\_\_init\_\_(self, xs)}}), printing (i.e. \code{\_\_repr\_\_(self)}), addition (\code{\_\_add\_\_(self, other)}), and evaluation (\code{eval(self, x)}).

Fill in the deleted parts of the code below to add the following functionality to Polynomial. For \code{p = Polynomial([1.0, 2.0, 0.0])} corresponding to the polynomial $1 + 2x^2 + 0x^3 = 1 + 2x2$. 

\begin{itemize}
  \item \code{p.cleanup()}, should modify \code{p} by removing the unnecessary 0-coefficients at the end of \code{p} (assume a float is zero if it is less than \code{epsilon = 0.00000000001}). For example, \code{ p = Polynomial([1.0,1.0,0.0000000000000000000000000001])}, \code{p.cleanup()}, \code{print(p)} should print \code{1.0 + 1.0x\char`\^1}. 
  \item \code{p.degree()} should return the degree of $p$. For example, \code{Polynomial([1.0, 0.0, 0.5]).degree()} should be 2. Be careful: \code{Polynomial([1.0, 0.0, 0.0, 0.00000000000000000001]).degree()} should be zero.
  \item \code{power\_of\_x(n)}, should return $x^n$ as a \code{Polynomial}. (this function should be outside the class) For example \code{print(power\_of\_x(4)) should print \code{1.0x\char`\^4}} (or similar depending on how you implemented print before)
  \item \code{p == q}, should return \code{True} if all the coefficients of \code{p} and \code{q} are within epsilon of each other, \code{False} otherwise. You do this by implementing a method called \code{\_\_eq\_\_(self, other)} in the Polynomial class. 
  \item \code{p * q}, should return the product of two polynomials. You do this by implementing \code{\_\_mul\_\_(self, other)} within the class.
  \item \code{p.derivative()}, should return the derivative of p(x).  
  \item \code{p.integral(a, b)}, should return the integral of p(x) from \code{a} to \code{b}.  
  \item (optional) \code{p.compose(q)} should return the composition of p and q. i.e. the resulting polynomial should be $p(q(x))$.

Make sure you test each method with a couple of examples. 
\end{itemize}

\begin{lstlisting}[language=Python]
class Polynomial():
    def __init__(self, xs):
      self.coeffs = xs
    def __repr__(self):
      # last homework 

    def __add__(self, other):
      # last homework 
    
    def eval(self, x):
      # last homework 
    
    # removes 0 coefficients in high degrees
    # e.g. p = Polynomial([1., 0., 2., 0., 0.])
    #      p.cleanup()
    #      print(p)
    # should give: 1.0x^0 + 0.0x^1 + 2.0x^2
    def cleanup(self):
      pass     # pass prevents python from error 
               # because function def is empty

    # returns degree of poynomial (be careful of extra 0's in high degrees)
    def degree(self):
      pass


    # checks if self and other have all coefficients within 10**(-11) of each other 
    def __eq__(self, other):
       pass 
   
    # scalar multiplies polynomial by number (modifies polynomial)
    def scalar_mult(self, alpha):
       pass 
   
    # returns the product polynomial of self and other
    def __mul__(self, other):
       pass 
   
    # returns the derivative of the polynomial with respect to x
    def derivative(self):
      pass

    # returns the integral of the polynomial from a to b 
    def integral(self, a, b):
      pass     

    # optional. returns the composition p(q(x))
    def compose(self, other):
      pass


# returns the nth power of x as a polynomial
def power_of_x(n):
  pass 
\end{lstlisting}





\end{document}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%






